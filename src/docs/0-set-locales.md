# Set up Locales

Start with what you do with any i18n library: set up locales and translation files.

## Define supported Locales

Create an enum of the locales you support and create a type for them.

```ts title="lib/poly-i18n/locales.ts"
export enum Locales {
  en = 'English',
  es = 'EspaÃ±ol',
}

export type LocaleCode = keyof typeof Locales
```

Then add a function that receives the user's desired locale and returns the locale you support that is closest to what they want. This will also take dialect specific locales like `en-US` or `en-GB` and return `en` as the closest match.

```ts title="lib/poly-i18n/locales.ts"
export function getSupportedLocale(userLocale: string | undefined): LocaleCode {
  const locale = Object.keys(Locales).find((supportedLocale) => {
    return userLocale?.includes(supportedLocale)
  }) as LocaleCode | undefined
  return locale || 'en' // ðŸ‘ˆ default to English if no match
}
```

## Add translation strings

Then add translation strings by creating a file for each locale you support. In this example we will support `en` and `es`.

```ts title="lib/poly-i18n/locales/en.js"
export default {
  hello: {
    world: 'Hello world!',
  },
}
```

Since English is our base language, when we create another language we can add type safety with one line:

```ts title="lib/poly-i18n/locales/es.js" {1}
/** @type {typeof import('./en.js').default} */
export default {
  hello: {
    world: 'Â¡Hola mundo!',
  },
}
```

You may already have your translations in `json` files and you may automatically sync them from a spreadsheet or cloud translation service, but it should be easy to add `export default` (and the type) to the top of each file.

## Translation key type-safety

We can also use our `en.js` file to give us some nice intellisense and type-checking as we use our translation keys in our app. Let's create a `TranslationKeys` type:

```ts title="lib/poly-i18n/types.ts"
import type en from './locales/en'

export type TranslationKeys = Flatten<TranslationKeysNested>

type TranslationKeysNested = {
  [K in keyof typeof en]: {
    [L in StringKeyof<typeof en[K]>]: `${K}.${L}`
  }
}[keyof typeof en]

type StringKeyof<T> = Extract<keyof T, string>
type Flatten<T> = T extends infer U ? { [K in keyof U]: U[K] } extends Record<keyof U, infer V> ? V : never : never
```

I use a nested structure with two levels (section and item), as in `header.title`. If you do something different, you'll need to adjust your type-checking accordingly.

Now let's set up any needed [[1-formatting]].

[//begin]: # "Autogenerated link references for markdown compatibility"
[1-formatting]: 1-formatting.md "Formatting"
[//end]: # "Autogenerated link references"